# Cpp_Design_pattern
# 一句话总结设计模式
----
## 创造型模式
创建型模式（Creational Pattern）对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

模式名称|总结
-------|-----
工厂模式|工厂方法在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型
抽象工厂模式|抽象工厂能创建一系列相关的对象，而无需指定其具体类
生成器模式|生成器模式能够使我们分步骤创建复杂的对象，使用相同的创建代码生成不同类型和形式的对象
原型模式|原型模式能够复制已有对象，而又无需使代码依赖它们所属的类。
单例模式|单例模式能够保证一个类只有一个实例，并提供一个访问该实例的全局节点

----
## 结构型模式
结构型模式（Structural Pattern）描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。结构型模式可以分为类结构型模式和对象结构型模式：
●  类结构型模式：关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系 
●  对象结构型模式：关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法 

模式名称|总结
-------|-----
适配器模式|让接口不兼容的对象能够相互合作
桥模式|可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构，从而能在开发时分别使用
组合模式|你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们
装饰器模式|允许你将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为
门面模式（外观模式）|能为程序库、框架或其他复杂类提供一个简单的接口
享元模式|摒弃了再每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在优先的内存容量中载入更多对象
代理模式|让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理

----
## 行为型模式


-----
## 各个模式的主要特点
### 工厂模式
工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用（即使用 new 运算符）。不用担心，对象仍将通过 new 运算符创建，只是该运算符改在工厂方法中调用罢了。工厂方法返回的对象通常被称作“产品”。

### 抽象工厂模式
抽象工厂为你提供了一个接口，可用于创建每个系列产品的对象。只要代码通过该接口创建对象，那么你就不会生成与应用程序已生成的产品类型不一致的产品。

### 生成器模式
生成器模式建议将对象构造代码从产品类中抽取出来，并将其放在一个名为生成器的独立对象中。重点在于你无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤即可。

### 原型模式
针对复制问题，如果你有一个对象，并希望生成与其完全相同的一个复制品，就采用原型模式，总的来说，支持对象克隆的就是原型。对于循环引用的对象，克隆可能会非常麻烦

### 单例模式
为什么会有人想要控制一个类所拥有的实例数量？最常见的原因是控制某些共享资源（例如数据库或文件）的访问权限。它的运作方式是这样的：如果你创建了一个对象，同时过一会儿后你决定再创建一个新对象，此时你会获得之前已创建的对象，而不是一个新对象。主要有两种实现方式：懒汉式和饿汉式，由创建实例的时间区分。其中比较推荐的懒汉单例是创建函数返回局部的静态变量的引用。

### 适配器模式
当两个类的接口发生冲突时，可以新建一个适配器类，实现两个类直接的中介。创建一个适配器——一个特殊的对象，能够转换对象接口，使其能与其他对象进行交互。例如json文件和xml文件接口不一致时可以实现两个文件之间的转化。适配器通常在已有的程序中使用。

### 桥模式
如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式。如果你希望在几个独立维度上扩展一个类，可使用该模式。如果你需要在运行时切换不同实现方法，可使用桥接模式。